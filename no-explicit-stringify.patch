
# This is a patch for Path-Iterator-Rule-0.012.orig to update it to Path-Iterator-Rule-0.012
# 
# To apply this patch:
# STEP 1: Chdir to the source directory.
# STEP 2: Run the 'applypatch' program with this patch file as input.
#
# If you do not have 'applypatch', it is part of the 'makepatch' package
# that you can fetch from the Comprehensive Perl Archive Network:
# http://www.perl.com/CPAN/authors/Johan_Vromans/makepatch-x.y.tar.gz
# In the above URL, 'x' should be 2 or higher.
#
# To apply this patch without the use of 'applypatch':
# STEP 1: Chdir to the source directory.
# STEP 2: Run the 'patch' program with this file as input.
#
#### End of Preamble ####

#### Patch data follows ####
diff -c 'Path-Iterator-Rule-0.012.orig/lib/Path/Iterator/Rule.pm' 'Path-Iterator-Rule-0.012/lib/Path/Iterator/Rule.pm'
Index: ./lib/Path/Iterator/Rule.pm
*** ./lib/Path/Iterator/Rule.pm	Wed Feb 13 20:41:02 2013
--- ./lib/Path/Iterator/Rule.pm	Fri Feb 15 10:50:14 2013
***************
*** 142,148 ****
              return $item->[0] if ref $item eq 'ARRAY'; # deferred for postorder
              my $string_item = "$item";
              if ( !$opt_follow_symlinks ) {
!                 redo LOOP if -l $string_item;
              }
  
              # by default, we're interested in everything and prune nothing
--- 142,148 ----
              return $item->[0] if ref $item eq 'ARRAY'; # deferred for postorder
              my $string_item = "$item";
              if ( !$opt_follow_symlinks ) {
!                 redo LOOP if -l $item;
              }
  
              # by default, we're interested in everything and prune nothing
***************
*** 170,180 ****
              }
  
              # if it's a directory, maybe add children to the queue
!             if (   -d $string_item
                  && !$prune
                  && ( !$opt_loop_safe || $self->_is_unique( $string_item, $stash ) ) )
              {
!                 if ( !-r $string_item ) {
                      warnings::warnif("Directory '$string_item' is not readable. Skipping it");
                  }
                  else {
--- 170,181 ----
              }
  
              # if it's a directory, maybe add children to the queue
!             if (   -d $item
                  && !$prune
                  && ( !$opt_loop_safe || $self->_is_unique( $string_item, $stash ) ) )
              {
!                 if ( !-r $item ) {
! 
                      warnings::warnif("Directory '$string_item' is not readable. Skipping it");
                  }
                  else {
***************
*** 374,381 ****
  
  # "simple" helpers take no arguments
  my %simple_helpers = (
!     directory => sub { -d "$_" },             # see also -d => dir below
!     dangling => sub { -l "$_" && !stat "$_" },
  );
  
  while ( my ( $k, $v ) = each %simple_helpers ) {
--- 375,382 ----
  
  # "simple" helpers take no arguments
  my %simple_helpers = (
!     directory => sub { -d $_ },             # see also -d => dir below
!     dangling => sub { -l $_ && !stat $_ },
  );
  
  while ( my ( $k, $v ) = each %simple_helpers ) {
***************
*** 386,399 ****
      my (@patterns) = @_;
      if ( @patterns > 1 ) {
          return sub {
!             my $name = "$_[1]";
              return ( first { $name =~ $_ } @patterns ) ? 1 : 0;
            }
      }
      else {
          my $pattern = $patterns[0];
          return sub {
!             my $name = "$_[1]";
              return $name =~ $pattern ? 1 : 0;
            }
      }
--- 387,401 ----
      my (@patterns) = @_;
      if ( @patterns > 1 ) {
          return sub {
!             my $name = $_[1];
              return ( first { $name =~ $_ } @patterns ) ? 1 : 0;
            }
      }
      else {
          my $pattern = $patterns[0];
          return sub {
! 	    $DB::single=1;
!             my $name = $_[1];
              return $name =~ $pattern ? 1 : 0;
            }
      }
***************
*** 430,437 ****
          my @patterns = map { _regexify($_) } @_;
          return sub {
              my $f = shift;
!             return unless !-d "$f";
!             open my $fh, "<", "$f";
              my $shebang = <$fh>;
              return unless defined $shebang;
              return ( first { $shebang =~ $_ } @patterns ) ? 1 : 0;
--- 432,439 ----
          my @patterns = map { _regexify($_) } @_;
          return sub {
              my $f = shift;
!             return unless !-d $f;
!             open my $fh, "<", $f;
              my $shebang = <$fh>;
              return unless defined $shebang;
              return ( first { $shebang =~ $_ } @patterns ) ? 1 : 0;
***************
*** 449,455 ****
          Carp::croak("No patterns provided to 'skip_dirs'") unless @_;
          my $name_check = Path::Iterator::Rule->new->name(@_);
          return sub {
!             return "0 but true" if -d "$_[0]" && $name_check->test(@_);
              return 1; # otherwise, like a null rule
            }
        } => 1 # don't create not_skip_dirs
--- 451,457 ----
          Carp::croak("No patterns provided to 'skip_dirs'") unless @_;
          my $name_check = Path::Iterator::Rule->new->name(@_);
          return sub {
!             return "0 but true" if -d $_[0] && $name_check->test(@_);
              return 1; # otherwise, like a null rule
            }
        } => 1 # don't create not_skip_dirs
***************
*** 478,491 ****
  #>>>
  
  while ( my ( $op, $name ) = each %X_tests ) {
!     my $coderef = eval "sub { $op qq{\$_} }"; ## no critic
      __PACKAGE__->add_helper( $name, sub { return $coderef } );
  }
  
  my %time_tests = ( -A => accessed => -M => modified => -C => changed => );
  
  while ( my ( $op, $name ) = each %time_tests ) {
!     my $filetest = eval "sub { $op qq{\$_} }"; ## no critic
      my $coderef  = sub {
          Carp::croak("The '$name' test requires a single argument") unless @_ == 1;
          my $comparator = Number::Compare->new(shift);
--- 480,493 ----
  #>>>
  
  while ( my ( $op, $name ) = each %X_tests ) {
!     my $coderef = eval "sub { $op \$_ }"; ## no critic
      __PACKAGE__->add_helper( $name, sub { return $coderef } );
  }
  
  my %time_tests = ( -A => accessed => -M => modified => -C => changed => );
  
  while ( my ( $op, $name ) = each %time_tests ) {
!     my $filetest = eval "sub { $op \$_ }"; ## no critic
      my $coderef  = sub {
          Carp::croak("The '$name' test requires a single argument") unless @_ == 1;
          my $comparator = Number::Compare->new(shift);
***************
*** 504,510 ****
      my $coderef = sub {
          Carp::croak("The '$name' test requires a single argument") unless @_ == 1;
          my $comparator = Number::Compare->new(shift);
!         return sub { return $comparator->( ( stat("$_") )[$i] ) };
      };
      __PACKAGE__->add_helper( $name, $coderef );
  }
--- 506,512 ----
      my $coderef = sub {
          Carp::croak("The '$name' test requires a single argument") unless @_ == 1;
          my $comparator = Number::Compare->new(shift);
!         return sub { return $comparator->( ( stat($_) )[$i] ) };
      };
      __PACKAGE__->add_helper( $name, $coderef );
  }
#### End of Patch data ####

#### ApplyPatch data follows ####
# Data version        : 1.0
# Date generated      : Fri Feb 15 10:56:15 2013
# Generated by        : makepatch 2.04
# Recurse directories : Yes
# Excluded files      : (\A|/).*\~\Z
#                       (\A|/).*\.a\Z
#                       (\A|/).*\.bak\Z
#                       (\A|/).*\.BAK\Z
#                       (\A|/).*\.elc\Z
#                       (\A|/).*\.exe\Z
#                       (\A|/).*\.gz\Z
#                       (\A|/).*\.ln\Z
#                       (\A|/).*\.o\Z
#                       (\A|/).*\.obj\Z
#                       (\A|/).*\.olb\Z
#                       (\A|/).*\.old\Z
#                       (\A|/).*\.orig\Z
#                       (\A|/).*\.rej\Z
#                       (\A|/).*\.so\Z
#                       (\A|/).*\.Z\Z
#                       (\A|/)\.del\-.*\Z
#                       (\A|/)\.make\.state\Z
#                       (\A|/)\.nse_depinfo\Z
#                       (\A|/)core\Z
#                       (\A|/)tags\Z
#                       (\A|/)TAGS\Z
# p 'lib/Path/Iterator/Rule.pm' 41409 1360943414 0100644
#### End of ApplyPatch data ####

#### End of Patch kit [created: Fri Feb 15 10:56:15 2013] ####
#### Patch checksum: 216 7730 48385 ####
#### Checksum: 234 8445 42178 ####
